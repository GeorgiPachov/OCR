Софийски университет „Св. Климент Охридски”
Факултет по математика и информатика

Курсов проект

по Изкуствен интелект

на тема: 
"Разпознаване на текст от изображение (OCR)"

Изготвили:
Весела Рудева 
и 
Георги Пачов

при преподаватели:
доц. д-р Иван Койчев
Тодор Цонков

Цел: 
Да се създаде софтуер, който обработва изображение на текст и извлича графичните символи и намира съответното им машинно кодиране. Това дава възможност да се създаде текстов файл с текста то изображението и той да се обработва машинно.


Необходимост:
В днешно време е много по-лесно и удобно информацията да се съхранява в електронен формат. Това важи в пълна степен за всякакви текстови документи – от автобиография на кандидат за работа до архивите на МВР. Но информационните технологии са навлезли в широка употреба сравнително скоро. Много хора все още не са свикнали с тях и предпочитат да подават документи на хартиен носител до административни органи. Но един документ се обработва много по-бързо, когато е в електронен формат. Разбира се, хартиеният документ може да се сканира, но сканираното изображение не е текстов файл, а за да обработим лесно документа, то той ни е нужен като текстов файл. Тук може да помогне софтуер за разпознаване на текст от изображение. 
Софтуерът за разпознаване на текст от изображение прави текста по-лесен и удобен за обработване. Веднъж извлечен в текстов файл, текстът може да се копира. Също така, в текста може да се търсят низове от символи. Текстовите файлове могат да се конвертират в човешка реч, както например при навигационните системи. Един такъв софтуер може да намери широко приложение сред всички хора, работещи с документи, книги или други хартиени носители на информация в писмен вид, от ученици до служители в администрация. Може да е от полза на служителите на КАТ – например, за извличане на регистрационния номер на автомобил от снимка, направена от пътна камера. Може да е полезна на обикновения човек, който иска да си обнови автобиографията, но я има само на хартиен носител. Може да е полезна и на служителя в човешки ресурси – при обработване болничния лист на даден служител, тъй като болничните листове все още се издават само на хартиен носител. 
Основната мотивация за разработването на софтуер за разпознаване на символи от изображение е била голяма част от информацията да стане по-лесно достъпна за незрящите хора. Много малко са книгите, написани и на Брайлова азбука, а посредством софтуера за конвертиране на текст в човешка реч, от машинно кодиран текст могат да се създават аудио книги. Всяка една книга на хартиен носител, може да бъде сканирана, обработена със софтуера за разпознаване на текст от изображение и по този начин превърната в текстов файл.

Начини за решаване на проблема:
Всички алгоритми за конвертиране на текст от изображение в текстов формат се наричат с общото име Optical Character Recognition(разпознаване на оптични символи (OCR)). Определението за (OCR) e: "Механично или електронно преобразуване на изображения на ръкопис, машинопис или отпечатан текст към машинно кодиран текст". През последните години са създадени и алгоритмите за интелигентно разпознаване на символи (Intelligent Character Recognition (ICR)), които всъщност представляват подобрение на (OCR). ICR се използва за подобрявате на точността при разпознаване на ръкописни текстове с различни стилове. Последното подобрение на ICR алгоритмите е алгоритъмът за интелигентно разпознаване на думи Intelligent word recognition (IWR), при разпознаването на символи той използва контекста на с целите думи или дори фрази, в които се намира даден символ.
Всички OCR алгоритми включват 2 основни етапа:
обработка на изображението, за постигане на по-добро качество;
разделяне на изображението на множество от изображения на отделните фрази, думи или символи.
разпознаване на символите от обработеното изображение;
Целта на обработването на изображението е да се постигне по-добро качество, да се изчистят шумове и дефекти. Това трябва да подпомогне по-коректното разпознаване на символите. Основно се използват филтри за бинаризиране на изображението, т. е. превръщането му в абсолютно черно-бяло изображение без сиви тонове. Процесът на бинаризация е много важен, защото при неправилно такава може да се загуби голяма част от информацията. Някои OCR алгоритми прилагат на входното изображение матрица за завъртане на образа. Това помага когато текстът на сниман под наклон. Обикновено се прилагат един или няколко филтъра за премахване на шум от изображението. В текстовете често се подчертават отделни фрагменти, за да се наблегне на тяхната важност. Но това подчертаване се явява като шум за OCR алгоритмите. За да се премахне такъв вид шум, се използват алгоритми за откриване и премахване на дълги прави линии от началното изображение. По-съвършените OCR програми разделят изображението на множество от зони и установяват, в кои зони има текст и в кои друга информация, както и различни характеристики на текстовете в различните зони.
Разделянето на изображението на множество от изображения на символи може да стане като се използват празните разстояния между символите. Не при всички шрифтове обаче има разстояние между символите. В този случай задачата за отделяне на символите става много сложна. Текстът се разделя на думи и всяка дума се обработва по специфичен начин, за да се отделят символите й. 
След като сме получили изображенията на отделните символи задачата вече може да се сведе до класификация на символите. Някои известни алгоритми за класификация са дърво на решението (decision tree), наивен Бейсов класификатор (Naive Bayes), kNN, невронни мрежи (neural networks). За класифицирането трябва да се подбере обучаващо множество и да се определят атрибутите му. За атрибути се използват дъгите и отсечките, които съставят символите, пикселите от изображението, могат да се включат и атрибути на контекста, в който участва символа, като предходна или следваща буква, останалите символи от думата.
Дървото на решения е една от най лесните и същевременно успешни форми за обучаване на алгоритъм. Входните данни при този алгоритъм са обект или ситуация описани с множество от атрибути, а изходът е решение – предвиденият клас. Дървото на решението достига до крайното си решение, след като изпълни последователност от проверки. Всеки възел на дървото отговаря за проверката на един от атрибутите на входните данни. Клоновете от възела са обозначени с възможните изходни стойности от проверката. Всеки възел на дървото задава решението, което ще се върне, ако се достигне този връх. Дървото на решението се използва лесно за намиране на решение. По-трудно е неговото построяване. Трудността се състои в избирането на реда, по който атрибутите влизат като върхове на дървото. За построяването на дървото се ползват данни от обучаващото множество.  За корен се ползва атрибутът, определянето на чиято стойност би донесло най-много информация. След това от корена се създават толкова клонове колкото са възможните стойности на атрибута и всеки клон сочи към поддърво образувано по същия начин от тези примери от обучаващото множество, които имат съответната за клона стойност на кореновия атрибут.
Невронните мрежи се състоят от елементи(неврони) и връзки между тях. Връзките са с посока. Всяка връзка има тегло и може да активизира елемента. От връзките невроните получават входни данни, умножават входа от връзката по нейното тегло, сумират получения резултати и върху сумата прилагат специално функция наречена активизираща функция. Така се получава резултатът, който да бъде пратен на следващия неврон. Резултатът от последният неврон е класът в който се разпределят входните данни. В зависимост от разположението на невроните невронните мрежи могат да бъдат еднослойни, многослойни или рекурентни. При рекурентните невронни мрежи са образуват цикли от невроните и връзките. Изходната информация от един неврон може да достигне отново до него, след като е преминала през няколко други неврона. По този начин се постига ефект на запомняне наподобяващ този на човешкия мозък. Заради този ефект сложни невронни мрежи са много ефективни при редица задачи за класификация.  Невронни мрежи за OCR са използвани в проекта Tessaract, който е разработен в лабораториите на HP между 1985 и 1995, а в момента се поддържа от Google.
Алгоритъмът на к-те най-близки съседа (K nierest neighbours – kNN) класифицира данните, намирайки най-близките по-стойности на атрибутите к на брой съседи. Основното  при използването му е да се избере, даващата най-добри резултати, стойност за параметъра к и подходяща функция за пресмятане на разстоянието между обекта, който класифицираме и обектите от обучаващото множество. За пресмята не разстоянието се използват стойностите на атрибутите. То може да се изчисли по формулите за евклидово разстояние, хемингово разстояние , и още много други. Формулите се прилагат за различна размерност на пространството. Размерността на пространството е толкова, колкото на брой са атрибутите на обектите.  Формулата за разстояние се избира в зависимост от вида на атрибутите и допустимите им стойности. След като се изчисли разстоянието между обекта, който класифицираме, и всеки един обект от обучаващото множество, к-те най-близки обекта от обучаващото множество гласуват какъв е класът на класифициращият се обект. Всеки обект дава глас за класа, в който се намира той. За клас на обекта, който класифицираме, се избира класът получил най-много гласове. Параметърът к не може да бъде ефективно избран преди написването на програмата. За да се избере подходяща стойност за к се използва метод наречен crossvalidation. При него се избира подмножество от обучаващото множество. Това множество се нарича тестово множество. Тестовото множество се изключва от обучаващото множество. За избрано к алгоритъмът се пуска с входни данни тестовото множество. Получените резултати се сравняват с реалните класове на тестовите данни и се определя процентът на успеваемост на алгоритъма за съответното к. Процедурата се повтаря с различни тестови множества за различни стойности на к. За окончателна стойност на параметъра к се избира тази, при която са показани най-добри стойности на успеваемост.
Избраната от нас реализация:
Избраният от нас подход за реализация и мотивацията за избора са описани в следните стъпки:
Стъпка 1: Прилагане на филтър за преминаване в сивата скала (Greyscale Filter)
Намира се средната стойност на наситеността на червеното, зеленото и синьото, за всеки пиксел. Тази средна стойност се задава за всеки цвят (червено, зелено, синьо) на пиксела. Така пикселът има същата яркост,  но на цвят е сив. Всеки пиксел с по-висока от тази яркост се преобразува в чисто бял, а ако е с по-ниска - в чисто черен.
Стъпка 2: Бинаризация на изображението (Binarization) – преминаване в абсолютно черно-бяло
От сивото изображение се намират пикселът с най-висока яркост и този с най-ниска. Изчислява се средната стойност на двете яркости.
Стъпка 3: Разделяне на редовете на изображението
Редовете се отделят като се търси празно пространство, т. е. състоящо се само от бели пиксели. Празното пространство се прескача. Щом в един ред от матрицата на изображението бъде намерен черен пиксел започва да се записва изображението на текстов ред. Това продължава докато се намери ред от матрицата на изображението съставен само от бели пиксели.
Стъпка 4: Разделяне на отделните символи от всеки ред
Разделянето на символите става също както разделянето на редовете но се работи не по редовете на матрицата, а по колоните. След като бъдат получени изображенията на символите от тях се изрязват всички обграждащи ги бели полета.
Стъпка 5: Класификация 
За класификация на символите избрахме алгоритъма kNN.Разстоянието изчисляваме като добавяме единица, ако стойностите на атрибутите съвпадат. След крос валидация избрахме стойността на параметъра к да бъде 3. Сами създаваме обучаващото множество.
5.1: Създаване на обучаващо множество
Обучаващото множество създаваме като генерираме клас от обекти за всеки видим символ от ASCII таблицата. В класът се включва символът изписан с всички достъпни за операционната система шрифтове. По този начин обучаващото множество зависи от наличните шрифтове и може да се определя от потребителя в зависимост от нуждите му, като се има предвид, че колкото по-голямо е то толкова по-точно работи програмата, но това и отнема повече време.
5.2: Скалиране на размерите на обектите от обучаващото множество спрямо размера на класифициращият се обект
Изчислява се отношението на ширината и височината на обекта, който класифицираме, и на обекта от обучаващото множество. Намира се тяхната разлика. В зависимост от стойността на разликата, обекта от обучаващото множество се скалира с размери като обекта, който ще класифицираме, или не. Скалирането ни е необходимо, за да не получаваме грешна информация, породена от различните размери и пропорции на изображенията.
5.3: Изчисляване на разстоянието между класифициращият се обект и обект от обучаващото множество
Формулата за изчисляване на разстоянието работи върху входни данни две матрици със стойности 0, 1. Разстоянието се изчислява като към сумата се добавя 1, ако двата пиксела съвпадат и са бели и 2 ако съвпадат и са черни. Т. е. черните пиксели имат по-голяма тежест. Накрая сумата се дели на общият брой пиксели.
5.4: Класифициране на обекта
За класификация на символите избрахме алгоритъма kNN, защото обучаването му се извършва практически за време 0 и има статистически данни за задоволителни резултати при използването му за разпознаване на ръкописни цифри. За атрибути на елементите ползваме пикселите от изображението, те са най-интуитивните и лесни за използване атрибути. Има възможност за добавяне на допълнителни атрибути като вид на предходния символ – буква / друг символ, ако е буква дали е гласна или съгласна и други подобни, на не успяхме да намерим статистически резултати са вероятностите на последователност на символите.   
Както е представено в описанието на алгоритъма, след като се изчисли разстоянието между класифициращият се обект и обектите от обучаващото множество избираме за клас класът, за който са дали най-много гласове трите най-близки съседи.
5.5: Избор на к
Направихме крос валидация със стойности на к 1, 3, 4, 5. Върху тестови множества образувани от случайно избрани 10 шрифта. Въз основа на получените резултати избрахме к да бъде равно на 3. Резултатите са представени като процент успешно разпознати символи в следната таблица:

<Тук напрявих едни таблици и не мога да ги прехвърля>																						

Трябва да отбележим, че тези данни не отговарят на познаваемостта при използване на реални данни. Това се дължи на факта, че тестовите данни, получени като подмножество на обучаващото множество, не съдържат никакъв шум. 
Проблеми и неточности:
При входно изображение с ниско качество или високи нива на шум се губи голяма част от информацията.
Ако два символа не са разделени с интервал, не се разделят и съответно се разпознават неправилно.
При наклонени изображения (когато редовете не са хоризонтални) редовете не се разграничават.
При много малки разстояния межди редовете, когато ченгелите на буквите от два реда са така разположени, че могат да се пресекат от хоризонтална линия, двата реда се разпознават в един. 
Има групи сходни по между си символи, които често се бъркат един с друг. Например O – 0, S - $, l - t - ! - | - I, w – m, _ -, A – 4, ? - 2 .
За да се постигне по-високо степен на разпознаване на буквите, понеже те носят основната информация в текста, е намален процентът на правилно разпознаване на други символи.

Използвана литература:
•	Artificial Intelligence A Modern Approach 
•	Image Binarization using Otsu method - Xu Liang, NLPR-PAL Group, CASIA
•	A Fast algorithm for multilevel thresholding - Ping-Sung Liao, Tse-Sheng Chen and PAU-Choo Chung


